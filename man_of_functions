###############
### main.c; ###
###############
	MAIN:
#Before Loop;
- initialise toutes les variables necessaires (ft_init)
- print la banniere (ft_banner)
- definit le comportement a adopter pour chaque signal (ft_set_sig_handler)
#Loop;
- read chaque entree du clavier
- gere le stockage de la commande tape (tcaps_manage_printable)
- gere l affichage de chaque entree de clavier (tcaps)
- redirige process vers l execution de cmd quand l user press "Enter" (tcaps_enter)
#After loop;
- free toutes les variables si necessaire
- return le retour d execution


	TCAPS_MANAGE_PRINTABLE_CHAR: <t_env *e>
- gere le stockage de chaque nouvelle entree de clavier si c est un char imprimable
	|-> si le curseur a etait deplace au milieu de la commande, gere en plus l affichage
		|-> supprime la cmd actuelle + le prompt et reaffiche lensemble


	TCAPS_ENTER: <t_env *e>
- ramene le curseur a la fin de la cmd actuelle (facilite la gestion des termcaps pour les cmd multi-lignes) (tcap_ctrl_end)
- redirige process vers le parsing de la cmd qui lui amene a l execution (ft_parse_line)



###################
### ft_parse.c; ###
###################
	FT_PARSE_LINE; <t_env *e>
- split la cmd (stocke dans e->line) en fonction des ';' (ft_trim_split_cmd)
- stock la cmd dans /tmp/.history et initialise la gestion de l historique (ft_check_history)
- boucle autant de fois qu il y a de commandes au total (ex: "ls; pwd" -> 2 cmds)
|-> gere les cas ou il manque des parentheses (ft_matchquotes)

	FT_ITER_PIPES; <t_env *e> <cmd content encore toutes les redirections>
- gere le parsing de la cmd
	e->cmd		: double tableau contenant chaque mot de la cmd (ft_strsplit_quotes)
	e->magic	: tableau de structure remplissant la variable cmd avec chaque mots de cmd or redirections (struct_strsplit_quote)
	e->cat		: triple tableau contenant des doubles tableaux contenant les cmds dans les pipes (or redirections) (ft_cmds_split)
		ex: ls | grep 21sh > test	-> cat[0][0] = "ls"
									-> cat[1][0] = "grep"
									-> cat[1][0] = "21sh";
- associe chaque mot (presant dans e->cmd) a un type (cmd, redirection, output, input) (magic_type)
- gere la priorite des cmds (ft_create_file)
#Loop;
- boucle tant qu'il y a un pipe ou plus
- redirige le process vers l'execition (redir_exec_open)
- reinitialise les FD standard apres chaque execution (dup2)
#After Loop;
- execute la derniere (ou la seule si une seule cmd donnee) cmd (redir_last_cmd)
- reinitialise les variables:
	|-> free le triple tableau e->cat (ft_triple_free)
	|-> reinitialise RED_INDEX qui permet de se balader dans e->magic, de redirection en redirection
	|-> [...]

	FT_EXEC_BUILTIN; <t_env *e> <builtin a executer: contient les parametres mais pas les redirections>
- gere les cas de redirections (premier if)
- redirige le process vers la fonction de builtin adequate

	FT_TRIM_SPLIT_CMD; <t_env *e>
- clean la cmd (stocke dans e->line) des tabulations
- split la cmd via ';'
- return un double tableau contenant toutes les cmd separees par des ';'



####################
#### ft_signal.c ###
####################

	FT_SET_SIG_HANDLER; <void>
#Loop:
- aosscie chaque signal a un comportement donnee
	|-> sig <= 31 car il y a au total 31 signaux
	|-> associe le comportement par default aux signaux donnes (1er if)
	|-> renvoit chaque autres signaux vers une gestion perso (ft_sig_handler)

	FT_SIG_HANDLET; <code du signal>
- gere la gestion du signal "Ctrl + c" (kill le process en cour)

	FT_HANDLE_RET_SIGNAL; <retour de la commande precedement execute>
- gere l'affichage du message lorsqu'un signal est envoye (current + ft_sigcheck)

	FT_SIG_CHECK; <code du signal>
- gere l'affichage du message en fonction du signal



#################
### ft_exec.c ###
#################

	FT_EXEC_CMD; <t_env *e> <cmd comprenant seulement les parametres, sans les redirections>
(FONCTIONS SEULEMENT UTILISE SI LA CMD N EST PAS UN BUILTIN)
- remplace les tildes (='~') par leur equivalent present dans l'env
- redirige le process vers l'executions d'un builtin ou d'une cmd

	FT_EXEC; <cmd comprenant seulement les parametres, sans les redirections> <t_env *e>
- recupere l empalcement de l executable si il existe (step1: ft_find_paths, step2: ft_find_exec)
- check si l executable existe et si l user a les droits dessus (access)
- si OK, redirige le process vers l'execution de la cmd (ft_fork_exec)
- reinitialise les variables

	FT_FORK_EXEC; <nom de la cmd> <dlbe tableau contenant la cmd + ses options> <t_env *e>
- creer un processus fils pour executer la cmd (singletonne(fork()))
#Process Fils: (dans else)
-gere les redirections
- execute la cmd
#Process pere: (singletonne(-42) + apres execution)
- close les FD non necessaire
- gere le signal (si il y a eu) obtenue lors de l'execution de la derniere cmd

	FT_CLOSE; <file descriptor a fermer>
- close un fd donnee en gerant les erreurs possible

	FT_REDIRECT; <nouvelle destination du fd src> <fd src a dup2>
- redirige le flux du fd src vers le nouvel fd



#######################
### ft_cmds_split.c ###
#######################

	FT_CMDS_SPLIT; <t_env *e>
- alloue un triple tableau et le remplit avec chaque cmd entre les pipes or redirections
		ex: ls | grep 21sh > test	-> cat[0][0] = "ls"
									-> cat[1][0] = "grep"
									-> cat[1][0] = "21sh";

	FT_FIND_TAB; <t_env *e> <index permettant de se balader dans e->magic>
- initialise et remplit un double tableau content la prochaine cmd entre pipe (or redirection)

	FT_NB_ELEM_CMD; <t_env *e> <index permettant de se balader dans e->magic>
- calcul le nbre d elemts present dans la prochaine commande (ex: ls -l > test1 --> 2)
- stock les fichiers de redirections (1er if) ex: ls > test1 >> test2 => stockera test1, test2
- stock les elems de la cmd sans les redirections